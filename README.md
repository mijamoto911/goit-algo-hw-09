
### Greedy algorithm:

* Execution time: A greedy algorithm is expected to have a lower execution time, especially for large sums. This is because of a simple and effective way of selecting the highest denomination coins.
* Memory space: Memory consumption should also be small, since the algorithm chooses coins one by one without storing all possible combinations.

### Dynamic programming algorithm:
* Execution time: Although the dynamic programming algorithm can take more time, especially with large amounts, its advantage is that it guarantees to find the minimum number of coins.
* Memory space: Memory costs can be significant due to the need to store information for every possible denomination and amount.
  
### General conclusions:
* If it is important to minimize the number of coins, use a dynamic programming algorithm.
* If the main criterion is execution speed and efficiency for large sums, you can give preference to the greedy algorithm.
* 
Given the specifics of the task and time and memory constraints, the best algorithm may depend on the particular use.

_____________________________________________________________


### Жадібний алгоритм:

* Час виконання: З жадібного алгоритму очікується більш низький час виконання, особливо при великих сумах. Це через простий та ефективний спосіб вибору монет з найвищим номіналом.
* Простір пам'яті: Витрати пам'яті також повинні бути невеликими, оскільки алгоритм обирає монети одну за одною без зберігання всіх можливих комбінацій.
* 
### Алгоритм динамічного програмування:

* Час виконання: Хоча алгоритм динамічного програмування може забрати більше часу, особливо при великих сумах, його перевага полягає в тому, що він гарантує знаходження мінімальної кількості монет.
* Простір пам'яті: Витрати пам'яті можуть бути значними через потребу зберігання інформації для кожного можливого номіналу та суми.
* 
### Загальні висновки:

* Якщо важливо мінімізувати кількість монет, використовуйте алгоритм динамічного програмування.
* Якщо основний критерій - швидкість виконання та ефективність для великих сум, можна віддати перевагу жадібному алгоритму.
* 
Враховуючи специфіку задачі та обмеження щодо часу та пам'яті, кращий алгоритм може залежати від конкретного використання.